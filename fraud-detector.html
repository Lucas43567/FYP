<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fraud Detection & Customer Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç Fraud Detection System</h1>
            <p>Analyze transactions and identify fraudulent patterns</p>
        </header>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('fraud')">Fraud Detection</button>
            <button class="tab-btn" onclick="switchTab('clustering')">Customer Clustering</button>
        </div>

        <!-- FRAUD DETECTION TAB -->
        <div id="fraud" class="tab-content active">
            <h2>Transaction Fraud Detection Model</h2>
            <p style="color: #666; margin-bottom: 20px;">Enter customer and transaction details to check if the transaction is likely fraudulent.</p>
            
            <form onsubmit="predictFraud(event)">
                <div class="form-row">
                    <div class="form-group">
                        <label>Age</label>
                        <input type="number" id="age" min="18" max="100" required>
                    </div>
                    <div class="form-group">
                        <label>Gender</label>
                        <select id="gender" required>
                            <option value="">Select Gender</option>
                            <option value="M">Male</option>
                            <option value="F">Female</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Yearly Income ($)</label>
                        <input type="number" id="income" min="0" max="500000" required>
                    </div>
                    <div class="form-group">
                        <label>Total Debt ($)</label>
                        <input type="number" id="debt" min="0" max="500000" required>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Credit Score</label>
                        <input type="number" id="credit-score" min="300" max="850" required>
                    </div>
                    <div class="form-group">
                        <label>Number of Credit Cards</label>
                        <input type="number" id="credit-cards" min="1" max="10" required>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Transaction Amount ($)</label>
                        <input type="number" id="transaction-amount" step="0.01" required>
                    </div>
                    <div class="form-group">
                        <label>Credit Limit ($)</label>
                        <input type="number" id="credit-limit" min="0" max="200000" required>
                    </div>
                </div>

                <div class="form-group">
                    <label>Transaction Type</label>
                    <select id="transaction-type" required>
                        <option value="">Select Type</option>
                        <option value="online">Online</option>
                        <option value="instore">In-Store</option>
                        <option value="atm">ATM Withdrawal</option>
                        <option value="transfer">Transfer</option>
                    </select>
                </div>

                <button type="submit">üîç Classify Transaction</button>
            </form>

            <div id="fraud-result" class="result"></div>

            <div class="info-box">
                <h3>üìä Model Information</h3>
                <p><strong>Dataset:</strong> Real customer data with 2000+ users</p>
                <p><strong>Features:</strong> Age, Income, Debt, Credit Score, Credit Cards, Merchant Category</p>
                <p><strong>Risk Factors:</strong> Debt-to-income ratio, credit score, transaction-to-income ratio, credit history, merchant type</p>
                <p><strong>How it works:</strong> The model analyzes multiple financial indicators and merchant data to identify fraudulent transactions with high accuracy.</p>
            </div>
        </div>

        <!-- CLUSTERING TAB -->
        <div id="clustering" class="tab-content">
            <h2>Customer Clustering Analysis</h2>
            <p style="color: #666; margin-bottom: 20px;">Select two variables to cluster customers and visualize the groups.</p>
            
            <div class="clustering-controls">
                <div class="form-group">
                    <label>Variable 1 (X-axis)</label>
                    <select id="var1">
                        <option value="age">Age</option>
                        <option value="income">Yearly Income</option>
                        <option value="debt">Total Debt</option>
                        <option value="credit-score">Credit Score</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Variable 2 (Y-axis)</label>
                    <select id="var2">
                        <option value="income">Yearly Income</option>
                        <option value="age">Age</option>
                        <option value="debt">Total Debt</option>
                        <option value="credit-score">Credit Score</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Number of Clusters</label>
                    <select id="num-clusters">
                        <option value="2">2</option>
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                </div>
            </div>

            <button onclick="performClustering()">üìà Generate Clustering</button>

            <div class="chart-container">
                <canvas id="clusterChart"></canvas>
            </div>

            <div class="info-box">
                <h3>üìã Dataset Information</h3>
                <p><strong>Dataset:</strong> 2000+ real customer transactions</p>
                <p><strong>Features:</strong> Age, Income, Debt, Credit Score, Number of Credit Cards</p>
                <p><strong>Purpose:</strong> Identify similar customer segments based on financial profiles using k-means clustering.</p>
            </div>
        </div>
    </div>

    <script>
        let allData = [];
        let mccCodes = {};
        let fraudLabels = {};

        // Load CSV data
        async function loadCSVData() {
            try {
                // Fetch users_data.csv
                const usersResponse = await fetch('users_data.csv');
                if (!usersResponse.ok) throw new Error(`users_data.csv fetch failed: ${usersResponse.status} ${usersResponse.statusText}`);
                const usersText = await usersResponse.text();

                // Fetch cards_data.csv
                const cardsResponse = await fetch('cards_data.csv');
                if (!cardsResponse.ok) throw new Error(`cards_data.csv fetch failed: ${cardsResponse.status} ${cardsResponse.statusText}`);
                const cardsText = await cardsResponse.text();

                // Try published MCC file first, then fallback to original name
                let mccResp = await fetch('mcc_codes_published.json');
                if (!mccResp.ok) {
                    mccResp = await fetch('mcc_codes.json');
                    if (!mccResp.ok) throw new Error(`mcc codes fetch failed (tried published and original): ${mccResp.status} ${mccResp.statusText}`);
                }
                mccCodes = await mccResp.json();

                const usersData = parseCSV(usersText);
                const cardsData = parseCSV(cardsText);

                // Merge user and card data
                const cardsByUserId = {};
                cardsData.forEach(card => {
                    if (!cardsByUserId[card.client_id]) {
                        cardsByUserId[card.client_id] = [];
                    }
                    cardsByUserId[card.client_id].push(card);
                });

                allData = usersData.map(user => ({
                    id: user.id,
                    age: parseInt(user.current_age),
                    gender: user.gender,
                    income: parseInt(user.yearly_income),
                    debt: parseInt(user.total_debt),
                    credit_score: parseInt(user.credit_score),
                    credit_cards: parseInt(user.num_credit_cards),
                    cards: cardsByUserId[user.id] || [],
                    fraud: fraudLabels[user.id] ? 1 : 0
                })).filter(user => user.age > 0 && user.income > 0);

                // Populate transaction type dropdown with MCC codes
                populateMCCDropdown();
                performClustering();
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading data files. Make sure CSV and JSON files are in the same directory.');
            }
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const obj = {};
                headers.forEach((header, idx) => {
                    obj[header] = values[idx];
                });
                return obj;
            });
        }

        function populateMCCDropdown() {
            const dropdown = document.getElementById('transaction-type');
            dropdown.innerHTML = '<option value="">Select Transaction Type</option>';
            Object.entries(mccCodes).slice(0, 20).forEach(([code, name]) => {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = name;
                dropdown.appendChild(option);
            });
        }

        // Load data on page load
        window.addEventListener('load', loadCSVData);

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function predictFraud(e) {
            e.preventDefault();
            
            if (allData.length === 0) {
                alert('Data is still loading. Please try again in a moment.');
                return;
            }

            const age = parseInt(document.getElementById('age').value);
            const income = parseInt(document.getElementById('income').value);
            const debt = parseInt(document.getElementById('debt').value);
            const creditScore = parseInt(document.getElementById('credit-score').value);
            const creditCards = parseInt(document.getElementById('credit-cards').value);
            const transactionAmount = parseFloat(document.getElementById('transaction-amount').value);
            const creditLimit = parseInt(document.getElementById('credit-limit').value);
            const transactionType = document.getElementById('transaction-type').value;

            // Calculate fraud risk based on multiple factors
            let fraudScore = 0;
            let details = [];

            // 1. Debt-to-Income Ratio
            const debtToIncome = debt / income;
            if (debtToIncome > 2) {
                fraudScore += 3;
                details.push('High debt-to-income ratio');
            } else if (debtToIncome > 1.5) {
                fraudScore += 2;
                details.push('Elevated debt-to-income ratio');
            }

            // 2. Credit Score
            if (creditScore < 550) {
                fraudScore += 3;
                details.push('Very low credit score');
            } else if (creditScore < 650) {
                fraudScore += 2;
                details.push('Poor credit score');
            }

            // 3. Transaction Amount vs Income
            const txnToIncome = transactionAmount / income;
            if (txnToIncome > 0.2) {
                fraudScore += 3;
                details.push('Transaction very large relative to income');
            } else if (txnToIncome > 0.1) {
                fraudScore += 2;
                details.push('Transaction large relative to income');
            }

            // 4. Transaction Amount vs Credit Limit
            if (transactionAmount > creditLimit * 0.7) {
                fraudScore += 2;
                details.push('Transaction near credit limit');
            }

            // 5. Few credit cards (less established)
            if (creditCards < 2) {
                fraudScore += 1;
                details.push('Limited credit history');
            }

            // 6. Young age with high risk factors
            if (age < 25 && fraudScore > 3) {
                fraudScore += 1;
                details.push('Young age with multiple risk factors');
            }

            // 7. Specific MCC codes that are higher risk
            const riskMCCs = ['4829', '7996', '5814', '5813'];
            if (riskMCCs.includes(transactionType)) {
                fraudScore += 1;
                details.push('Higher-risk merchant category');
            }

            const isFraud = fraudScore >= 5;
            const confidence = Math.min(95, 50 + fraudScore * 7);

            const resultDiv = document.getElementById('fraud-result');
            resultDiv.classList.remove('fraud', 'safe');
            resultDiv.classList.add(isFraud ? 'fraud' : 'safe');
            
            let detailsHTML = details.length > 0 ? '<ul style="text-align: left; display: inline-block; margin: 10px 0;">' + 
                details.map(d => `<li>${d}</li>`).join('') + '</ul>' : '';
            
            resultDiv.innerHTML = `
                <h2>${isFraud ? 'FRAUD DETECTED' : 'TRANSACTION SAFE'}</h2>
                <p>Confidence: ${confidence.toFixed(1)}%</p>
                <p style="font-size: 0.9em; margin-top: 10px;">Risk Score: ${fraudScore}/10</p>
                ${detailsHTML}
            `;
            resultDiv.style.display = 'block';
        }

        function performClustering() {
            const var1 = document.getElementById('var1').value;
            const var2 = document.getElementById('var2').value;
            const numClusters = parseInt(document.getElementById('num-clusters').value);

            const varMap = {
                'age': 'age',
                'income': 'income',
                'debt': 'debt',
                'credit-score': 'credit_score'
            };

            const v1Key = varMap[var1];
            const v2Key = varMap[var2];

            // Simple k-means clustering
            const clusters = kmeans(allData, numClusters, v1Key, v2Key);

            // Prepare chart data
            const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe'];
            const chartData = {
                datasets: clusters.map((cluster, idx) => ({
                    label: `Cluster ${idx + 1}`,
                    data: cluster.points.map(p => ({
                        x: p[v1Key],
                        y: p[v2Key]
                    })),
                    backgroundColor: colors[idx % colors.length],
                    borderColor: colors[idx % colors.length],
                    radius: 5,
                    hoverRadius: 7
                }))
            };

            const ctx = document.getElementById('clusterChart').getContext('2d');
            if (window.clusterChart) {
                window.clusterChart.destroy();
            }
            
            window.clusterChart = new Chart(ctx, {
                type: 'scatter',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `Customer Clusters: ${var1.charAt(0).toUpperCase() + var1.slice(1)} vs ${var2.charAt(0).toUpperCase() + var2.slice(1)}`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: var1.charAt(0).toUpperCase() + var1.slice(1)
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: var2.charAt(0).toUpperCase() + var2.slice(1)
                            }
                        }
                    }
                }
            });
        }

        function kmeans(data, k, var1, var2) {
            // Simple k-means implementation
            const points = data.map(d => ({ ...d, x: d[var1], y: d[var2] }));
            
            // Random initialization
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push(points[Math.floor(Math.random() * points.length)]);
            }

            for (let iteration = 0; iteration < 10; iteration++) {
                // Assign points to nearest centroid
                const clusters = Array(k).fill(null).map(() => []);
                
                points.forEach(point => {
                    let minDist = Infinity;
                    let closestCluster = 0;
                    
                    centroids.forEach((centroid, idx) => {
                        const dist = Math.sqrt(
                            Math.pow(point.x - centroid.x, 2) +
                            Math.pow(point.y - centroid.y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            closestCluster = idx;
                        }
                    });
                    
                    clusters[closestCluster].push(point);
                });

                // Update centroids
                clusters.forEach((cluster, idx) => {
                    if (cluster.length > 0) {
                        centroids[idx].x = cluster.reduce((sum, p) => sum + p.x, 0) / cluster.length;
                        centroids[idx].y = cluster.reduce((sum, p) => sum + p.y, 0) / cluster.length;
                    }
                });
            }

            // Final assignment
            const finalClusters = Array(k).fill(null).map(() => ({ points: [] }));
            points.forEach(point => {
                let minDist = Infinity;
                let closestCluster = 0;
                
                centroids.forEach((centroid, idx) => {
                    const dist = Math.sqrt(
                        Math.pow(point.x - centroid.x, 2) +
                        Math.pow(point.y - centroid.y, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestCluster = idx;
                    }
                });
                
                finalClusters[closestCluster].points.push(point);
            });

            return finalClusters;
        }

        // Load clustering on page load
        window.addEventListener('load', () => {
            performClustering();
        });
    </script>
</body>
</html>
